<!-- HyLightbox
 Description: A lightweight image viewer with zoom, drag, and drawing capabilities.
 Code type: HTML + CSS + JavaScript
-->
<!-- Template for lightbox structure -->
<template id="hylightbox-template">
    <div class="my-lightbox-wrapper">
        <img class="my-lightbox-image" src="" alt="Lightbox Image" />
        <canvas class="my-lightbox-canvas"></canvas>

        <!-- Control bar at top center -->
        <div class="my-lightbox-control-bar">
            <button class="my-lightbox-btn zoom-out-btn" title="Zoom Out (-)">−</button>
            <span class="my-lightbox-zoom-level">100%</span>
            <button class="my-lightbox-btn zoom-in-btn" title="Zoom In (+)">+</button>
        </div>

        <!-- Help button at top left -->
        <div class="my-lightbox-help-container">
            <button class="my-lightbox-btn help-btn" title="Help (?)">?</button>
            <div class="my-lightbox-help-tooltip">
                <p>键盘快捷键：</p>
                <ul>
                    <li>+ : 放大</li>
                    <li>- : 缩小</li>
                    <li>0 : 还原</li>
                    <li>R : 顺时针旋转45°</li>
                    <li>T : 逆时针旋转45°</li>
                    <li>ESC : 退出HyLightbox</li>
                    <li>1 : 回到鼠标模式</li>
                    <li>2 : 进入画笔模式（尚存bug）</li>
                </ul>
                <p>移动端可使用双指缩放</p>
            </div>
        </div>

        <!-- Close button at top right -->
        <div class="my-lightbox-close-container">
            <button class="my-lightbox-btn close-btn" title="Close (ESC)">×</button>
        </div>

        <!-- Rotate buttons at bottom left -->
        <div class="my-lightbox-rotate-container">
            <button class="my-lightbox-btn rotate-btn" title="Rotate CW (R)">↻</button>
            <button class="my-lightbox-btn rotate-counter-btn" title="Rotate CCW (T)">↺</button>
        </div>
    </div>
</template>

<style>
    .my-lightbox-wrapper {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 9999;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    .my-lightbox-wrapper.active {
        display: block;
    }

    .my-lightbox-image {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 90%;
        max-height: 90%;
        cursor: grab;
        transition: transform 0.2s ease;
        touch-action: none;
        user-select: none;
    }

    .my-lightbox-image.grabbing {
        cursor: grabbing;
        transition: none;
    }

    .my-lightbox-canvas {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        max-width: 90%;
        max-height: 90%;
        pointer-events: none;
    }

    /* Button base styles */
    .my-lightbox-btn {
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        line-height: 1;
        background: none;
        text-align: center;
        vertical-align: middle;
        -webkit-appearance: none;
        appearance: none;
        outline: none;
    }

    .my-lightbox-btn:hover,
    .my-lightbox-btn:focus,
    .my-lightbox-btn:active {
        background: none;
        outline: none;
        box-shadow: none;
    }

    /* Control bar */
    .my-lightbox-control-bar {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px 15px;
        border-radius: 20px;
        display: flex;
        align-items: center;
        gap: 15px;
        z-index: 10000;
    }

    .my-lightbox-zoom-level {
        color: white;
        font-size: 14px;
        font-family: Arial, sans-serif;
        min-width: 60px;
        text-align: center;
        display: inline-block;
        line-height: 30px;
    }

    /* Help button and tooltip */
    .my-lightbox-help-container {
        position: absolute;
        top: 20px;
        left: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 20px;
        padding: 5px 15px;
        z-index: 10000;
    }

    .my-lightbox-help-tooltip {
        display: none;
        position: absolute;
        top: 45px;
        left: 0;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 15px 20px;
        border-radius: 10px;
        color: white;
        font-size: 14px;
        width: 245px;
        z-index: 9999;
        line-height: 1.1;
    }

    .my-lightbox-help-tooltip.visible {
        display: block;
    }

    .my-lightbox-help-tooltip p {
        margin: 0;
    }

    .my-lightbox-help-tooltip p:first-child {
        margin-bottom: 4px;
    }

    .my-lightbox-help-tooltip p:last-child {
        margin-top: 4px;
    }

    .my-lightbox-help-tooltip ul {
        margin: 0;
        padding-left: 20px;
        list-style-type: disc;
    }

    .my-lightbox-help-tooltip li {
        margin: 0 0 2px 0;
        list-style-type: disc;
    }

    /* Close button */
    .my-lightbox-close-container {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 20px;
        padding: 5px 15px;
        z-index: 10000;
    }

    /* Rotate buttons */
    .my-lightbox-rotate-container {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 20px;
        padding: 5px 15px;
        z-index: 10000;
    }

    .my-lightbox-rotate-container .rotate-counter-btn {
        margin-left: 10px;
    }
</style>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const template = document.getElementById("hylightbox-template");
        if (!template) return;

        const lightboxWrapper = template.content.cloneNode(true);
        document.body.appendChild(lightboxWrapper);

        // Get DOM elements
        const wrapper = document.querySelector(".my-lightbox-wrapper");
        const lightboxImage = document.querySelector(".my-lightbox-image");
        const canvas = document.querySelector(".my-lightbox-canvas");
        const ctx = canvas.getContext("2d");
        const zoomLevel = document.querySelector(".my-lightbox-zoom-level");
        const zoomInBtn = document.querySelector(".zoom-in-btn");
        const zoomOutBtn = document.querySelector(".zoom-out-btn");
        const closeBtn = document.querySelector(".close-btn");
        const helpBtn = document.querySelector(".help-btn");
        const helpTooltip = document.querySelector(".my-lightbox-help-tooltip");
        const rotateBtn = document.querySelector(".rotate-btn");
        const rotateCounterBtn = document.querySelector(".rotate-counter-btn");

        // Constants
        const ROTATION_STEP = 45;
        const KEYBOARD_OFFSET = 30;
        const MIN_SCALE = 0.01;
        const MAX_SCALE = 1000;
        const ZOOM_FACTORS = { small: 1.05, medium: 1.125, large: 1.25, huge: 1.5 };

        // State object - consolidated for better organization
        const state = {
            isDragging: false,
            isHelpVisible: false,
            isDrawing: false,
            isPainting: false,
            isSingleTouch: false,
            initialDistance: 0,
            initialScale: 1,
            currentX: 0,
            currentY: 0,
            initialX: 0,
            initialY: 0,
            transform: {
                xOffset: 0,
                yOffset: 0,
                scale: 1,
                rotation: 0,
            },
        };

        // Helper function to get zoom factor based on current scale
        function getZoomFactor() {
            const { scale } = state.transform;
            if (scale < 1) return ZOOM_FACTORS.small;
            if (scale < 10) return ZOOM_FACTORS.medium;
            if (scale < 100) return ZOOM_FACTORS.large;
            return ZOOM_FACTORS.huge;
        }

        // Open lightbox
        function openLightbox(src) {
            wrapper.classList.add("active");
            document.body.style.overflow = "hidden";

            const tempImg = new Image();
            tempImg.onload = function () {
                lightboxImage.src = src;
                resetImagePosition();
                canvas.width = this.width;
                canvas.height = this.height;
            };
            tempImg.src = src;
        }

        // Close lightbox
        function closeLightbox() {
            wrapper.classList.remove("active");
            document.body.style.overflow = "";
            resetImagePosition();
            state.isHelpVisible = false;
            helpTooltip.classList.remove("visible");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            state.isDrawing = false;
        }

        // Reset image position
        function resetImagePosition() {
            state.transform.xOffset = 0;
            state.transform.yOffset = 0;
            state.transform.scale = 1;
            state.transform.rotation = 0;
            updateImageTransform();
            lightboxImage.style.cursor = "grab";
        }

        // Update image transform - optimized to reduce reflows
        function updateImageTransform() {
            const { xOffset, yOffset, scale, rotation } = state.transform;
            const transformString = `translate(calc(-50% + ${xOffset}px), calc(-50% + ${yOffset}px)) scale(${scale}) rotate(${rotation}deg)`;
            lightboxImage.style.transform = transformString;
            canvas.style.transform = transformString;
            updateZoomLevelDisplay();
        }

        // Update zoom level display
        function updateZoomLevelDisplay() {
            zoomLevel.textContent = `${Math.round(state.transform.scale * 100)}%`;
        }

        // Zoom operations
        function zoom(direction) {
            const factor = getZoomFactor();
            state.transform.scale = direction === "in" ? Math.min(state.transform.scale * factor, MAX_SCALE) : Math.max(state.transform.scale / factor, MIN_SCALE);
            updateImageTransform();
        }

        // Drag handlers
        function dragStart(e) {
            if (state.isDrawing) return;

            if (e.type === "touchstart") {
                if (e.touches.length === 2) {
                    state.isSingleTouch = false;
                    return;
                }
                state.isSingleTouch = true;
                state.initialX = e.touches[0].clientX - state.transform.xOffset;
                state.initialY = e.touches[0].clientY - state.transform.yOffset;
            } else {
                state.initialX = e.clientX - state.transform.xOffset;
                state.initialY = e.clientY - state.transform.yOffset;
            }

            if (e.target === lightboxImage) {
                state.isDragging = true;
                lightboxImage.classList.add("grabbing");
            }
        }

        function drag(e) {
            if (!state.isDragging || state.isDrawing) return;
            e.preventDefault();

            if (e.type === "touchmove") {
                if (e.touches.length === 2 || !state.isSingleTouch) return;
                state.currentX = e.touches[0].clientX - state.initialX;
                state.currentY = e.touches[0].clientY - state.initialY;
            } else {
                state.currentX = e.clientX - state.initialX;
                state.currentY = e.clientY - state.initialY;
            }

            state.transform.xOffset = state.currentX;
            state.transform.yOffset = state.currentY;
            updateImageTransform();
        }

        function dragEnd() {
            state.isDragging = false;
            state.isSingleTouch = false;
            lightboxImage.classList.remove("grabbing");
        }

        // Touch pinch zoom
        function getDistance(touch1, touch2) {
            return Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
        }

        function handlePinchZoom(e) {
            if (state.isSingleTouch) {
                drag(e);
                return;
            }

            e.preventDefault();
            e.stopPropagation();

            if (e.touches.length === 2) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);

                if (state.initialDistance === 0) {
                    state.initialDistance = currentDistance;
                    state.initialScale = state.transform.scale;
                } else {
                    const newScale = Math.min(Math.max(state.initialScale * (currentDistance / state.initialDistance), MIN_SCALE), MAX_SCALE);
                    state.transform.scale = newScale;
                    updateImageTransform();
                }
            }
        }

        function handleTouchEnd() {
            state.initialDistance = 0;
            dragEnd();
        }

        // Painting handlers - optimized to cache canvas rect
        let cachedCanvasRect = null;

        function getCachedCanvasRect() {
            if (!cachedCanvasRect) {
                cachedCanvasRect = canvas.getBoundingClientRect();
            }
            return cachedCanvasRect;
        }

        function startPainting(e) {
            if (!state.isDrawing) return;
            state.isPainting = true;
            const rect = getCachedCanvasRect();
            const { xOffset, yOffset, scale } = state.transform;
            const x = (e.clientX - rect.left) / scale - xOffset / scale;
            const y = (e.clientY - rect.top) / scale - yOffset / scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
        }

        function paint(e) {
            if (!state.isPainting || !state.isDrawing) return;
            const rect = getCachedCanvasRect();
            const { xOffset, yOffset, scale } = state.transform;
            const x = (e.clientX - rect.left) / scale - xOffset / scale;
            const y = (e.clientY - rect.top) / scale - yOffset / scale;
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function stopPainting() {
            if (!state.isDrawing) return;
            state.isPainting = false;
            ctx.closePath();
            cachedCanvasRect = null;
        }

        // Image click to open
        document.body.addEventListener("click", function (e) {
            if (e.target.tagName === "IMG" && !e.target.classList.contains("my-lightbox-image")) {
                e.preventDefault();
                openLightbox(e.target.src);
            }
        });

        // Mouse cursor styles for images
        document.body.addEventListener(
            "mouseenter",
            function (e) {
                if (e.target.tagName === "IMG" && !e.target.classList.contains("my-lightbox-image")) {
                    e.target.style.cursor = "zoom-in";
                }
            },
            true,
        );

        document.body.addEventListener(
            "mouseleave",
            function (e) {
                if (e.target.tagName === "IMG" && !e.target.classList.contains("my-lightbox-image")) {
                    e.target.style.cursor = "auto";
                }
            },
            true,
        );

        // Button events
        zoomInBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            zoom("in");
        });

        zoomOutBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            zoom("out");
        });

        rotateBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            state.transform.rotation += ROTATION_STEP;
            updateImageTransform();
        });

        rotateCounterBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            state.transform.rotation -= ROTATION_STEP;
            updateImageTransform();
        });

        closeBtn.addEventListener("click", closeLightbox);

        helpBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            state.isHelpVisible = !state.isHelpVisible;
            helpTooltip.classList.toggle("visible");
        });

        // Close help tooltip when clicking elsewhere
        wrapper.addEventListener("click", function (e) {
            if (state.isHelpVisible && !helpTooltip.contains(e.target) && e.target !== helpBtn) {
                state.isHelpVisible = false;
                helpTooltip.classList.remove("visible");
            }
            if (e.target === wrapper) {
                closeLightbox();
            }
        });

        // Keyboard events
        document.addEventListener("keydown", function (e) {
            if (!wrapper.classList.contains("active")) return;

            switch (e.key) {
                case "+":
                case "=":
                    e.preventDefault();
                    zoom("in");
                    break;
                case "-":
                case "_":
                    e.preventDefault();
                    zoom("out");
                    break;
                case "0":
                    e.preventDefault();
                    resetImagePosition();
                    break;
                case "Escape":
                    e.preventDefault();
                    closeLightbox();
                    break;
                case "1":
                    e.preventDefault();
                    state.isDrawing = false;
                    lightboxImage.style.cursor = "grab";
                    canvas.style.pointerEvents = "none";
                    break;
                case "2":
                    e.preventDefault();
                    state.isDrawing = true;
                    lightboxImage.style.cursor = "crosshair";
                    canvas.style.pointerEvents = "auto";
                    break;
                case "r":
                case "R":
                    e.preventDefault();
                    state.transform.rotation += ROTATION_STEP;
                    updateImageTransform();
                    break;
                case "t":
                case "T":
                    e.preventDefault();
                    state.transform.rotation -= ROTATION_STEP;
                    updateImageTransform();
                    break;
                case "ArrowUp":
                    e.preventDefault();
                    state.transform.yOffset += KEYBOARD_OFFSET;
                    updateImageTransform();
                    break;
                case "ArrowDown":
                    e.preventDefault();
                    state.transform.yOffset -= KEYBOARD_OFFSET;
                    updateImageTransform();
                    break;
                case "ArrowLeft":
                    e.preventDefault();
                    state.transform.xOffset += KEYBOARD_OFFSET;
                    updateImageTransform();
                    break;
                case "ArrowRight":
                    e.preventDefault();
                    state.transform.xOffset -= KEYBOARD_OFFSET;
                    updateImageTransform();
                    break;
            }
        });

        // Mouse events
        wrapper.addEventListener("mousedown", dragStart, { passive: false });
        wrapper.addEventListener("mousemove", drag, { passive: false });
        wrapper.addEventListener("mouseup", dragEnd);
        wrapper.addEventListener("mouseleave", dragEnd);

        // Touch events
        wrapper.addEventListener("touchstart", dragStart, { passive: false });
        wrapper.addEventListener("touchmove", handlePinchZoom, { passive: false });
        wrapper.addEventListener("touchend", handleTouchEnd);

        // Prevent image dragging
        lightboxImage.addEventListener("dragstart", (e) => e.preventDefault());

        // Disable page zoom while lightbox is open
        document.addEventListener(
            "touchmove",
            function (e) {
                if (wrapper.classList.contains("active")) {
                    e.preventDefault();
                }
            },
            { passive: false },
        );

        // Canvas painting events
        canvas.addEventListener("mousedown", startPainting);
        canvas.addEventListener("mousemove", paint);
        canvas.addEventListener("mouseup", stopPainting);
        canvas.addEventListener("mouseout", stopPainting);

        canvas.addEventListener("touchstart", (e) => startPainting(e.touches[0]));
        canvas.addEventListener("touchmove", (e) => paint(e.touches[0]));
        canvas.addEventListener("touchend", stopPainting);
    });
</script>
